{"version":3,"sources":["webpack:///webpack/bootstrap 3f992db1b075ea4ade0f","webpack:///./resources/assets/js/vendor/u2f/u2f-api.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","js_api_version","u2f","EXTENSION_ID","MessageTypes","U2F_REGISTER_REQUEST","U2F_REGISTER_RESPONSE","U2F_SIGN_REQUEST","U2F_SIGN_RESPONSE","U2F_GET_API_VERSION_REQUEST","U2F_GET_API_VERSION_RESPONSE","ErrorCodes","OK","OTHER_ERROR","BAD_REQUEST","CONFIGURATION_UNSUPPORTED","DEVICE_INELIGIBLE","TIMEOUT","U2fRequest","U2fResponse","Error","Transport","Transports","SignRequest","SignResponse","RegisterRequest","RegisterResponse","RegisteredKey","GetJsApiVersionResponse","getMessagePort","callback","chrome","runtime","msg","type","signRequests","sendMessage","lastError","getIframePort_","getChromeRuntimePort_","isAndroidChrome_","getAuthenticatorPort_","isIosChrome_","getIosPort_","userAgent","navigator","indexOf","platform","port","connect","includeTlsChannelId","setTimeout","WrappedChromeRuntimePort_","WrappedAuthenticatorPort_","WrappedIosPort_","this","port_","formatSignRequest_","appId","challenge","registeredKeys","timeoutSeconds","reqId","undefined","length","version","keyHandle","requestId","formatRegisterRequest_","registerRequests","postMessage","message","addEventListener","eventName","handler","toLowerCase","onMessage","addListener","data","console","error","requestId_","requestObject_","intentUrl","INTENT_URL_BASE_","encodeURIComponent","JSON","stringify","document","location","getPortType","window","onRequestUpdate_","bind","messageObject","parse","responseObject","str","url","encodeURI","replace","iframeOrigin","iframe","createElement","src","setAttribute","body","appendChild","channel","MessageChannel","port1","ready","removeEventListener","start","contentWindow","port2","EXTENSION_TIMEOUT_SEC","waitingForPort_","reqCounter_","callbackMap_","getPortSingleton_","responseHandler_","shift","push","response","cb","sign","opt_timeoutSeconds","getApiVersion","log","sendSignRequest","req","register","sendRegisterRequest","apiVersion"],"mappings":"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","file":"/js/u2f-api.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 3f992db1b075ea4ade0f","//Copyright 2014-2015 Google Inc. All rights reserved.\n\n//Use of this source code is governed by a BSD-style\n//license that can be found in the LICENSE file or at\n//https://developers.google.com/open-source/licenses/bsd\n\n/**\n * @fileoverview The U2F api.\n */\n'use strict';\n\n\n/**\n * Namespace for the U2F api.\n * @type {Object}\n */\nvar u2f = u2f || {};\n\n/**\n * FIDO U2F Javascript API Version\n * @number\n */\nvar js_api_version;\n\n/**\n * The U2F extension id\n * @const {string}\n */\n// The Chrome packaged app extension ID.\n// Uncomment this if you want to deploy a server instance that uses\n// the package Chrome app and does not require installing the U2F Chrome extension.\n u2f.EXTENSION_ID = 'kmendfapggjehodndflmmgagdbamhnfd';\n// The U2F Chrome extension ID.\n// Uncomment this if you want to deploy a server instance that uses\n// the U2F Chrome extension to authenticate.\n// u2f.EXTENSION_ID = 'pfboblefjcgdjicmnffhdgionmgcdmne';\n\n\n/**\n * Message types for messsages to/from the extension\n * @const\n * @enum {string}\n */\nu2f.MessageTypes = {\n    'U2F_REGISTER_REQUEST': 'u2f_register_request',\n    'U2F_REGISTER_RESPONSE': 'u2f_register_response',\n    'U2F_SIGN_REQUEST': 'u2f_sign_request',\n    'U2F_SIGN_RESPONSE': 'u2f_sign_response',\n    'U2F_GET_API_VERSION_REQUEST': 'u2f_get_api_version_request',\n    'U2F_GET_API_VERSION_RESPONSE': 'u2f_get_api_version_response'\n};\n\n\n/**\n * Response status codes\n * @const\n * @enum {number}\n */\nu2f.ErrorCodes = {\n    'OK': 0,\n    'OTHER_ERROR': 1,\n    'BAD_REQUEST': 2,\n    'CONFIGURATION_UNSUPPORTED': 3,\n    'DEVICE_INELIGIBLE': 4,\n    'TIMEOUT': 5\n};\n\n\n/**\n * A message for registration requests\n * @typedef {{\n *   type: u2f.MessageTypes,\n *   appId: ?string,\n *   timeoutSeconds: ?number,\n *   requestId: ?number\n * }}\n */\nu2f.U2fRequest;\n\n\n/**\n * A message for registration responses\n * @typedef {{\n *   type: u2f.MessageTypes,\n *   responseData: (u2f.Error | u2f.RegisterResponse | u2f.SignResponse),\n *   requestId: ?number\n * }}\n */\nu2f.U2fResponse;\n\n\n/**\n * An error object for responses\n * @typedef {{\n *   errorCode: u2f.ErrorCodes,\n *   errorMessage: ?string\n * }}\n */\nu2f.Error;\n\n/**\n * Data object for a single sign request.\n * @typedef {enum {BLUETOOTH_RADIO, BLUETOOTH_LOW_ENERGY, USB, NFC, USB_INTERNAL}}\n */\nu2f.Transport;\n\n\n/**\n * Data object for a single sign request.\n * @typedef {Array<u2f.Transport>}\n */\nu2f.Transports;\n\n/**\n * Data object for a single sign request.\n * @typedef {{\n *   version: string,\n *   challenge: string,\n *   keyHandle: string,\n *   appId: string\n * }}\n */\nu2f.SignRequest;\n\n\n/**\n * Data object for a sign response.\n * @typedef {{\n *   keyHandle: string,\n *   signatureData: string,\n *   clientData: string\n * }}\n */\nu2f.SignResponse;\n\n\n/**\n * Data object for a registration request.\n * @typedef {{\n *   version: string,\n *   challenge: string\n * }}\n */\nu2f.RegisterRequest;\n\n\n/**\n * Data object for a registration response.\n * @typedef {{\n *   version: string,\n *   keyHandle: string,\n *   transports: Transports,\n *   appId: string\n * }}\n */\nu2f.RegisterResponse;\n\n\n/**\n * Data object for a registered key.\n * @typedef {{\n *   version: string,\n *   keyHandle: string,\n *   transports: ?Transports,\n *   appId: ?string\n * }}\n */\nu2f.RegisteredKey;\n\n\n/**\n * Data object for a get API register response.\n * @typedef {{\n *   js_api_version: number\n * }}\n */\nu2f.GetJsApiVersionResponse;\n\n\n//Low level MessagePort API support\n\n/**\n * Sets up a MessagePort to the U2F extension using the\n * available mechanisms.\n * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n */\nu2f.getMessagePort = function(callback) {\n  if (typeof chrome != 'undefined' && chrome.runtime) {\n    // The actual message here does not matter, but we need to get a reply\n    // for the callback to run. Thus, send an empty signature request\n    // in order to get a failure response.\n    var msg = {\n        type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n        signRequests: []\n    };\n    chrome.runtime.sendMessage(u2f.EXTENSION_ID, msg, function() {\n      if (!chrome.runtime.lastError) {\n        // We are on a whitelisted origin and can talk directly\n        // with the extension.\n        u2f.getChromeRuntimePort_(callback);\n      } else {\n        // chrome.runtime was available, but we couldn't message\n        // the extension directly, use iframe\n        u2f.getIframePort_(callback);\n      }\n    });\n  } else if (u2f.isAndroidChrome_()) {\n    u2f.getAuthenticatorPort_(callback);\n  } else if (u2f.isIosChrome_()) {\n    u2f.getIosPort_(callback);\n  } else {\n    // chrome.runtime was not available at all, which is normal\n    // when this origin doesn't have access to any extensions.\n    u2f.getIframePort_(callback);\n  }\n};\n\n/**\n * Detect chrome running on android based on the browser's useragent.\n * @private\n */\nu2f.isAndroidChrome_ = function() {\n  var userAgent = navigator.userAgent;\n  return userAgent.indexOf('Chrome') != -1 &&\n  userAgent.indexOf('Android') != -1;\n};\n\n/**\n * Detect chrome running on iOS based on the browser's platform.\n * @private\n */\nu2f.isIosChrome_ = function() {\n  return [\"iPhone\", \"iPad\", \"iPod\"].indexOf(navigator.platform) > -1;\n};\n\n/**\n * Connects directly to the extension via chrome.runtime.connect.\n * @param {function(u2f.WrappedChromeRuntimePort_)} callback\n * @private\n */\nu2f.getChromeRuntimePort_ = function(callback) {\n  var port = chrome.runtime.connect(u2f.EXTENSION_ID,\n      {'includeTlsChannelId': true});\n  setTimeout(function() {\n    callback(new u2f.WrappedChromeRuntimePort_(port));\n  }, 0);\n};\n\n/**\n * Return a 'port' abstraction to the Authenticator app.\n * @param {function(u2f.WrappedAuthenticatorPort_)} callback\n * @private\n */\nu2f.getAuthenticatorPort_ = function(callback) {\n  setTimeout(function() {\n    callback(new u2f.WrappedAuthenticatorPort_());\n  }, 0);\n};\n\n/**\n * Return a 'port' abstraction to the iOS client app.\n * @param {function(u2f.WrappedIosPort_)} callback\n * @private\n */\nu2f.getIosPort_ = function(callback) {\n  setTimeout(function() {\n    callback(new u2f.WrappedIosPort_());\n  }, 0);\n};\n\n/**\n * A wrapper for chrome.runtime.Port that is compatible with MessagePort.\n * @param {Port} port\n * @constructor\n * @private\n */\nu2f.WrappedChromeRuntimePort_ = function(port) {\n  this.port_ = port;\n};\n\n/**\n * Format and return a sign request compliant with the JS API version supported by the extension.\n * @param {Array<u2f.SignRequest>} signRequests\n * @param {number} timeoutSeconds\n * @param {number} reqId\n * @return {Object}\n */\nu2f.formatSignRequest_ =\n  function(appId, challenge, registeredKeys, timeoutSeconds, reqId) {\n  if (js_api_version === undefined || js_api_version < 1.1) {\n    // Adapt request to the 1.0 JS API\n    var signRequests = [];\n    for (var i = 0; i < registeredKeys.length; i++) {\n      signRequests[i] = {\n          version: registeredKeys[i].version,\n          challenge: challenge,\n          keyHandle: registeredKeys[i].keyHandle,\n          appId: appId\n      };\n    }\n    return {\n      type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n      signRequests: signRequests,\n      timeoutSeconds: timeoutSeconds,\n      requestId: reqId\n    };\n  }\n  // JS 1.1 API\n  return {\n    type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n    appId: appId,\n    challenge: challenge,\n    registeredKeys: registeredKeys,\n    timeoutSeconds: timeoutSeconds,\n    requestId: reqId\n  };\n};\n\n/**\n * Format and return a register request compliant with the JS API version supported by the extension..\n * @param {Array<u2f.SignRequest>} signRequests\n * @param {Array<u2f.RegisterRequest>} signRequests\n * @param {number} timeoutSeconds\n * @param {number} reqId\n * @return {Object}\n */\nu2f.formatRegisterRequest_ =\n  function(appId, registeredKeys, registerRequests, timeoutSeconds, reqId) {\n  if (js_api_version === undefined || js_api_version < 1.1) {\n    // Adapt request to the 1.0 JS API\n    for (var i = 0; i < registerRequests.length; i++) {\n      registerRequests[i].appId = appId;\n    }\n    var signRequests = [];\n    for (var i = 0; i < registeredKeys.length; i++) {\n      signRequests[i] = {\n          version: registeredKeys[i].version,\n          challenge: registerRequests[0],\n          keyHandle: registeredKeys[i].keyHandle,\n          appId: appId\n      };\n    }\n    return {\n      type: u2f.MessageTypes.U2F_REGISTER_REQUEST,\n      signRequests: signRequests,\n      registerRequests: registerRequests,\n      timeoutSeconds: timeoutSeconds,\n      requestId: reqId\n    };\n  }\n  // JS 1.1 API\n  return {\n    type: u2f.MessageTypes.U2F_REGISTER_REQUEST,\n    appId: appId,\n    registerRequests: registerRequests,\n    registeredKeys: registeredKeys,\n    timeoutSeconds: timeoutSeconds,\n    requestId: reqId\n  };\n};\n\n\n/**\n * Posts a message on the underlying channel.\n * @param {Object} message\n */\nu2f.WrappedChromeRuntimePort_.prototype.postMessage = function(message) {\n  this.port_.postMessage(message);\n};\n\n\n/**\n * Emulates the HTML 5 addEventListener interface. Works only for the\n * onmessage event, which is hooked up to the chrome.runtime.Port.onMessage.\n * @param {string} eventName\n * @param {function({data: Object})} handler\n */\nu2f.WrappedChromeRuntimePort_.prototype.addEventListener =\n    function(eventName, handler) {\n  var name = eventName.toLowerCase();\n  if (name == 'message' || name == 'onmessage') {\n    this.port_.onMessage.addListener(function(message) {\n      // Emulate a minimal MessageEvent object\n      handler({'data': message});\n    });\n  } else {\n    console.error('WrappedChromeRuntimePort only supports onMessage');\n  }\n};\n\n/**\n * Wrap the Authenticator app with a MessagePort interface.\n * @constructor\n * @private\n */\nu2f.WrappedAuthenticatorPort_ = function() {\n  this.requestId_ = -1;\n  this.requestObject_ = null;\n}\n\n/**\n * Launch the Authenticator intent.\n * @param {Object} message\n */\nu2f.WrappedAuthenticatorPort_.prototype.postMessage = function(message) {\n  var intentUrl =\n    u2f.WrappedAuthenticatorPort_.INTENT_URL_BASE_ +\n    ';S.request=' + encodeURIComponent(JSON.stringify(message)) +\n    ';end';\n  document.location = intentUrl;\n};\n\n/**\n * Tells what type of port this is.\n * @return {String} port type\n */\nu2f.WrappedAuthenticatorPort_.prototype.getPortType = function() {\n  return \"WrappedAuthenticatorPort_\";\n};\n\n\n/**\n * Emulates the HTML 5 addEventListener interface.\n * @param {string} eventName\n * @param {function({data: Object})} handler\n */\nu2f.WrappedAuthenticatorPort_.prototype.addEventListener = function(eventName, handler) {\n  var name = eventName.toLowerCase();\n  if (name == 'message') {\n    var self = this;\n    /* Register a callback to that executes when\n     * chrome injects the response. */\n    window.addEventListener(\n        'message', self.onRequestUpdate_.bind(self, handler), false);\n  } else {\n    console.error('WrappedAuthenticatorPort only supports message');\n  }\n};\n\n/**\n * Callback invoked  when a response is received from the Authenticator.\n * @param function({data: Object}) callback\n * @param {Object} message message Object\n */\nu2f.WrappedAuthenticatorPort_.prototype.onRequestUpdate_ =\n    function(callback, message) {\n  var messageObject = JSON.parse(message.data);\n  var intentUrl = messageObject['intentURL'];\n\n  var errorCode = messageObject['errorCode'];\n  var responseObject = null;\n  if (messageObject.hasOwnProperty('data')) {\n    responseObject = /** @type {Object} */ (\n        JSON.parse(messageObject['data']));\n  }\n\n  callback({'data': responseObject});\n};\n\n/**\n * Base URL for intents to Authenticator.\n * @const\n * @private\n */\nu2f.WrappedAuthenticatorPort_.INTENT_URL_BASE_ =\n  'intent:#Intent;action=com.google.android.apps.authenticator.AUTHENTICATE';\n\n/**\n * Wrap the iOS client app with a MessagePort interface.\n * @constructor\n * @private\n */\nu2f.WrappedIosPort_ = function() {};\n\n/**\n * Launch the iOS client app request\n * @param {Object} message\n */\nu2f.WrappedIosPort_.prototype.postMessage = function(message) {\n  var str = JSON.stringify(message);\n  var url = \"u2f://auth?\" + encodeURI(str);\n  location.replace(url);\n};\n\n/**\n * Tells what type of port this is.\n * @return {String} port type\n */\nu2f.WrappedIosPort_.prototype.getPortType = function() {\n  return \"WrappedIosPort_\";\n};\n\n/**\n * Emulates the HTML 5 addEventListener interface.\n * @param {string} eventName\n * @param {function({data: Object})} handler\n */\nu2f.WrappedIosPort_.prototype.addEventListener = function(eventName, handler) {\n  var name = eventName.toLowerCase();\n  if (name !== 'message') {\n    console.error('WrappedIosPort only supports message');\n  }\n};\n\n/**\n * Sets up an embedded trampoline iframe, sourced from the extension.\n * @param {function(MessagePort)} callback\n * @private\n */\nu2f.getIframePort_ = function(callback) {\n  // Create the iframe\n  var iframeOrigin = 'chrome-extension://' + u2f.EXTENSION_ID;\n  var iframe = document.createElement('iframe');\n  iframe.src = iframeOrigin + '/u2f-comms.html';\n  iframe.setAttribute('style', 'display:none');\n  document.body.appendChild(iframe);\n\n  var channel = new MessageChannel();\n  var ready = function(message) {\n    if (message.data == 'ready') {\n      channel.port1.removeEventListener('message', ready);\n      callback(channel.port1);\n    } else {\n      console.error('First event on iframe port was not \"ready\"');\n    }\n  };\n  channel.port1.addEventListener('message', ready);\n  channel.port1.start();\n\n  iframe.addEventListener('load', function() {\n    // Deliver the port to the iframe and initialize\n    iframe.contentWindow.postMessage('init', iframeOrigin, [channel.port2]);\n  });\n};\n\n\n//High-level JS API\n\n/**\n * Default extension response timeout in seconds.\n * @const\n */\nu2f.EXTENSION_TIMEOUT_SEC = 30;\n\n/**\n * A singleton instance for a MessagePort to the extension.\n * @type {MessagePort|u2f.WrappedChromeRuntimePort_}\n * @private\n */\nu2f.port_ = null;\n\n/**\n * Callbacks waiting for a port\n * @type {Array<function((MessagePort|u2f.WrappedChromeRuntimePort_))>}\n * @private\n */\nu2f.waitingForPort_ = [];\n\n/**\n * A counter for requestIds.\n * @type {number}\n * @private\n */\nu2f.reqCounter_ = 0;\n\n/**\n * A map from requestIds to client callbacks\n * @type {Object.<number,(function((u2f.Error|u2f.RegisterResponse))\n *                       |function((u2f.Error|u2f.SignResponse)))>}\n * @private\n */\nu2f.callbackMap_ = {};\n\n/**\n * Creates or retrieves the MessagePort singleton to use.\n * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n * @private\n */\nu2f.getPortSingleton_ = function(callback) {\n  if (u2f.port_) {\n    callback(u2f.port_);\n  } else {\n    if (u2f.waitingForPort_.length == 0) {\n      u2f.getMessagePort(function(port) {\n        u2f.port_ = port;\n        u2f.port_.addEventListener('message',\n            /** @type {function(Event)} */ (u2f.responseHandler_));\n\n        // Careful, here be async callbacks. Maybe.\n        while (u2f.waitingForPort_.length)\n          u2f.waitingForPort_.shift()(u2f.port_);\n      });\n    }\n    u2f.waitingForPort_.push(callback);\n  }\n};\n\n/**\n * Handles response messages from the extension.\n * @param {MessageEvent.<u2f.Response>} message\n * @private\n */\nu2f.responseHandler_ = function(message) {\n  var response = message.data;\n  var reqId = response['requestId'];\n  if (!reqId || !u2f.callbackMap_[reqId]) {\n    console.error('Unknown or missing requestId in response.');\n    return;\n  }\n  var cb = u2f.callbackMap_[reqId];\n  delete u2f.callbackMap_[reqId];\n  cb(response['responseData']);\n};\n\n/**\n * Dispatches an array of sign requests to available U2F tokens.\n * If the JS API version supported by the extension is unknown, it first sends a\n * message to the extension to find out the supported API version and then it sends\n * the sign request.\n * @param {string=} appId\n * @param {string=} challenge\n * @param {Array<u2f.RegisteredKey>} registeredKeys\n * @param {function((u2f.Error|u2f.SignResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.sign = function(appId, challenge, registeredKeys, callback, opt_timeoutSeconds) {\n  if (js_api_version === undefined) {\n    // Send a message to get the extension to JS API version, then send the actual sign request.\n    u2f.getApiVersion(\n        function (response) {\n          js_api_version = response['js_api_version'] === undefined ? 0 : response['js_api_version'];\n          console.log(\"Extension JS API Version: \", js_api_version);\n          u2f.sendSignRequest(appId, challenge, registeredKeys, callback, opt_timeoutSeconds);\n        });\n  } else {\n    // We know the JS API version. Send the actual sign request in the supported API version.\n    u2f.sendSignRequest(appId, challenge, registeredKeys, callback, opt_timeoutSeconds);\n  }\n};\n\n/**\n * Dispatches an array of sign requests to available U2F tokens.\n * @param {string=} appId\n * @param {string=} challenge\n * @param {Array<u2f.RegisteredKey>} registeredKeys\n * @param {function((u2f.Error|u2f.SignResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.sendSignRequest = function(appId, challenge, registeredKeys, callback, opt_timeoutSeconds) {\n  u2f.getPortSingleton_(function(port) {\n    var reqId = ++u2f.reqCounter_;\n    u2f.callbackMap_[reqId] = callback;\n    var timeoutSeconds = (typeof opt_timeoutSeconds !== 'undefined' ?\n        opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC);\n    var req = u2f.formatSignRequest_(appId, challenge, registeredKeys, timeoutSeconds, reqId);\n    port.postMessage(req);\n  });\n};\n\n/**\n * Dispatches register requests to available U2F tokens. An array of sign\n * requests identifies already registered tokens.\n * If the JS API version supported by the extension is unknown, it first sends a\n * message to the extension to find out the supported API version and then it sends\n * the register request.\n * @param {string=} appId\n * @param {Array<u2f.RegisterRequest>} registerRequests\n * @param {Array<u2f.RegisteredKey>} registeredKeys\n * @param {function((u2f.Error|u2f.RegisterResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.register = function(appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds) {\n  if (js_api_version === undefined) {\n    // Send a message to get the extension to JS API version, then send the actual register request.\n    u2f.getApiVersion(\n        function (response) {\n          js_api_version = response['js_api_version'] === undefined ? 0: response['js_api_version'];\n          console.log(\"Extension JS API Version: \", js_api_version);\n          u2f.sendRegisterRequest(appId, registerRequests, registeredKeys,\n              callback, opt_timeoutSeconds);\n        });\n  } else {\n    // We know the JS API version. Send the actual register request in the supported API version.\n    u2f.sendRegisterRequest(appId, registerRequests, registeredKeys,\n        callback, opt_timeoutSeconds);\n  }\n};\n\n/**\n * Dispatches register requests to available U2F tokens. An array of sign\n * requests identifies already registered tokens.\n * @param {string=} appId\n * @param {Array<u2f.RegisterRequest>} registerRequests\n * @param {Array<u2f.RegisteredKey>} registeredKeys\n * @param {function((u2f.Error|u2f.RegisterResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.sendRegisterRequest = function(appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds) {\n  u2f.getPortSingleton_(function(port) {\n    var reqId = ++u2f.reqCounter_;\n    u2f.callbackMap_[reqId] = callback;\n    var timeoutSeconds = (typeof opt_timeoutSeconds !== 'undefined' ?\n        opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC);\n    var req = u2f.formatRegisterRequest_(\n        appId, registeredKeys, registerRequests, timeoutSeconds, reqId);\n    port.postMessage(req);\n  });\n};\n\n\n/**\n * Dispatches a message to the extension to find out the supported\n * JS API version.\n * If the user is on a mobile phone and is thus using Google Authenticator instead\n * of the Chrome extension, don't send the request and simply return 0.\n * @param {function((u2f.Error|u2f.GetJsApiVersionResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.getApiVersion = function(callback, opt_timeoutSeconds) {\n u2f.getPortSingleton_(function(port) {\n   // If we are using Android Google Authenticator or iOS client app,\n   // do not fire an intent to ask which JS API version to use.\n   if (port.getPortType) {\n     var apiVersion;\n     switch (port.getPortType()) {\n       case 'WrappedIosPort_':\n       case 'WrappedAuthenticatorPort_':\n         apiVersion = 1.1;\n         break;\n\n       default:\n         apiVersion = 0;\n         break;\n     }\n     callback({ 'js_api_version': apiVersion });\n     return;\n   }\n    var reqId = ++u2f.reqCounter_;\n    u2f.callbackMap_[reqId] = callback;\n    var req = {\n      type: u2f.MessageTypes.U2F_GET_API_VERSION_REQUEST,\n      timeoutSeconds: (typeof opt_timeoutSeconds !== 'undefined' ?\n          opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC),\n      requestId: reqId\n    };\n    port.postMessage(req);\n  });\n};\n\n\n\n// WEBPACK FOOTER //\n// ./resources/assets/js/vendor/u2f/u2f-api.js"],"sourceRoot":""}